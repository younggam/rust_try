/*Chapter 3 ====================================================
use rust_try_lib::*;

fn main() {
    let event_loop = winit::event_loop::EventLoop::new();
    let window = winit::window::WindowBuilder::new()
        .with_title("rust_try")
        .with_inner_size(winit::dpi::LogicalSize::new(512, 512))
        .build(&event_loop)
        .expect("Failed to create window.");
    let mut rust_try = RustTry::new(window);

    //
    event_loop.run(move |event, _, control_flow| match event {
        winit::event::Event::NewEvents(event) => match event {
            winit::event::StartCause::Init => {
                rust_try.on_startup();
            }
            //
            _ => {}
        },
        //
        winit::event::Event::WindowEvent { event, .. } => match event {
            winit::event::WindowEvent::CloseRequested => {
                *control_flow = winit::event_loop::ControlFlow::Exit;
            }
            //
            winit::event::WindowEvent::Destroyed => {
                rust_try.on_shutdown();
            }
            //
            winit::event::WindowEvent::KeyboardInput { input, .. } => match input {
                winit::event::KeyboardInput {
                    virtual_keycode,
                    state,
                    ..
                } => match (virtual_keycode, state) {
                    (
                        Some(winit::event::VirtualKeyCode::Escape),
                        winit::event::ElementState::Pressed,
                    ) => {
                        dbg!();
                        *control_flow = winit::event_loop::ControlFlow::Exit
                    }
                    //
                    _ => {}
                },
            },
            //
            _ => {}
        },
        //
        winit::event::Event::LoopDestroyed => {
            rust_try.on_shutdown();
        }
        //
        _ => {}
    });
    //
}
*/
/*Chapter 3 ====================================================
use ash::vk;
use rust_try_lib::ash;
use std::ffi::CString;

fn main() {
    let entry = unsafe { ash::Entry::new().unwrap() };

    //
    let layer_properties = entry
        .enumerate_instance_layer_properties()
        .expect("There is no available layer");
    layer_properties.iter().for_each(|x| println!("{:#?}", x));
    //

    //
    let layer_names = [CString::new("VK_LAYER_KHRONOS_validation").unwrap()];
    let layer_names_raw: Vec<*const i8> = layer_names
        .iter()
        .map(|raw_name| raw_name.as_ptr())
        .collect();

    let create_info = vk::InstanceCreateInfo::builder()
        .enabled_layer_names(&layer_names_raw)
        .build();

    let instance;
    instance = unsafe {
        entry
            .create_instance(&create_info, None)
            .expect("Instance creation error")
    };
    //

    //
    let physical_devices = unsafe {
        instance
            .enumerate_physical_devices()
            .expect("Physical device error")
    };

    physical_devices.iter().for_each(|device| {
        let properties = unsafe { instance.get_physical_device_properties(*device) };
        println!(
            "{}",
            String::from_utf8(unsafe { std::mem::transmute(properties.device_name.to_vec()) })
                .unwrap()
        );
    });

    let physical_device = physical_devices[0];
    //

    //
    let queue_family_properties =
        unsafe { instance.get_physical_device_queue_family_properties(physical_device) };

    let mut queue_family_index = usize::MAX;

    for (i, property) in queue_family_properties.iter().enumerate() {
        if property.queue_count > 0 && property.queue_flags.contains(vk::QueueFlags::GRAPHICS) {
            queue_family_index = i;
            break;
        }
    }
    let queue_family_index = queue_family_index as u32;

    println!("{}", queue_family_index);
    //

    //
    let priority: f32 = 1.0;

    let queue_create_info = vk::DeviceQueueCreateInfo::builder()
        .queue_family_index(queue_family_index)
        .queue_priorities(&[priority])
        .build();

    let device_create_info = vk::DeviceCreateInfo::builder()
        .queue_create_infos(&[queue_create_info])
        .build();

    let device = unsafe {
        instance
            .create_device(physical_device, &device_create_info, None)
            .expect("Device creation error")
    };
    //

    //
    let queue = unsafe { device.get_device_queue(queue_family_index, 0) };
    //
}*/

//another ================================
/*use rust_try_lib::*;

fn main() {
    VulkanApp::run();
}*/
